/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "MockImageDecoder.h"

typedef struct _CMOCK_ImageDecoderInit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_ImageDecoderInit_CALL_INSTANCE;

typedef struct _CMOCK_ImageLoopCallbackRegister_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  IMG_LOOP_CALLBACK Expected_pFn;

} CMOCK_ImageLoopCallbackRegister_CALL_INSTANCE;

typedef struct _CMOCK_ImageDecode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BYTE ReturnVal;
  IMG_FILE* Expected_pImageFile;
  IMG_FILE_FORMAT Expected_eImgFormat;
  WORD Expected_wStartx;
  WORD Expected_wStarty;
  WORD Expected_wWidth;
  WORD Expected_wHeight;
  WORD Expected_wFlags;
  IMG_FILE_SYSTEM_API* Expected_pFileAPIs;
  IMG_PIXEL_OUTPUT Expected_pPixelOutput;

} CMOCK_ImageDecode_CALL_INSTANCE;

typedef struct _CMOCK_IMG_vSetboundaries_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_IMG_vSetboundaries_CALL_INSTANCE;

static struct MockImageDecoderInstance
{
  CMOCK_MEM_INDEX_TYPE ImageDecoderInit_CallInstance;
  CMOCK_MEM_INDEX_TYPE ImageLoopCallbackRegister_CallInstance;
  CMOCK_MEM_INDEX_TYPE ImageDecode_CallInstance;
  CMOCK_MEM_INDEX_TYPE IMG_vSetboundaries_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void MockImageDecoder_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.ImageDecoderInit_CallInstance, cmock_line, "Function 'ImageDecoderInit' called less times than expected.");
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.ImageLoopCallbackRegister_CallInstance, cmock_line, "Function 'ImageLoopCallbackRegister' called less times than expected.");
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.ImageDecode_CallInstance, cmock_line, "Function 'ImageDecode' called less times than expected.");
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.IMG_vSetboundaries_CallInstance, cmock_line, "Function 'IMG_vSetboundaries' called less times than expected.");
}

void MockImageDecoder_Init(void)
{
  MockImageDecoder_Destroy();
}

void MockImageDecoder_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

void ImageDecoderInit(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ImageDecoderInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_ImageDecoderInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ImageDecoderInit_CallInstance);
  Mock.ImageDecoderInit_CallInstance = CMock_Guts_MemNext(Mock.ImageDecoderInit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'ImageDecoderInit' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
}

void ImageDecoderInit_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ImageDecoderInit_CALL_INSTANCE));
  CMOCK_ImageDecoderInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_ImageDecoderInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.ImageDecoderInit_CallInstance = CMock_Guts_MemChain(Mock.ImageDecoderInit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

void ImageLoopCallbackRegister(IMG_LOOP_CALLBACK pFn)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ImageLoopCallbackRegister_CALL_INSTANCE* cmock_call_instance = (CMOCK_ImageLoopCallbackRegister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ImageLoopCallbackRegister_CallInstance);
  Mock.ImageLoopCallbackRegister_CallInstance = CMock_Guts_MemNext(Mock.ImageLoopCallbackRegister_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'ImageLoopCallbackRegister' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pFn), (void*)(&pFn), sizeof(IMG_LOOP_CALLBACK), cmock_line, "Function 'ImageLoopCallbackRegister' called with unexpected value for argument 'pFn'.");
  }
}

void CMockExpectParameters_ImageLoopCallbackRegister(CMOCK_ImageLoopCallbackRegister_CALL_INSTANCE* cmock_call_instance, IMG_LOOP_CALLBACK pFn)
{
  memcpy(&cmock_call_instance->Expected_pFn, &pFn, sizeof(IMG_LOOP_CALLBACK));
}

void ImageLoopCallbackRegister_CMockExpect(UNITY_LINE_TYPE cmock_line, IMG_LOOP_CALLBACK pFn)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ImageLoopCallbackRegister_CALL_INSTANCE));
  CMOCK_ImageLoopCallbackRegister_CALL_INSTANCE* cmock_call_instance = (CMOCK_ImageLoopCallbackRegister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.ImageLoopCallbackRegister_CallInstance = CMock_Guts_MemChain(Mock.ImageLoopCallbackRegister_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ImageLoopCallbackRegister(cmock_call_instance, pFn);
}

BYTE ImageDecode(IMG_FILE* pImageFile, IMG_FILE_FORMAT eImgFormat, WORD wStartx, WORD wStarty, WORD wWidth, WORD wHeight, WORD wFlags, IMG_FILE_SYSTEM_API* pFileAPIs, IMG_PIXEL_OUTPUT pPixelOutput)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ImageDecode_CALL_INSTANCE* cmock_call_instance = (CMOCK_ImageDecode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ImageDecode_CallInstance);
  Mock.ImageDecode_CallInstance = CMock_Guts_MemNext(Mock.ImageDecode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'ImageDecode' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pImageFile), (void*)(pImageFile), sizeof(IMG_FILE), cmock_line, "Function 'ImageDecode' called with unexpected value for argument 'pImageFile'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eImgFormat), (void*)(&eImgFormat), sizeof(IMG_FILE_FORMAT), cmock_line, "Function 'ImageDecode' called with unexpected value for argument 'eImgFormat'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wStartx), (void*)(&wStartx), sizeof(WORD), cmock_line, "Function 'ImageDecode' called with unexpected value for argument 'wStartx'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wStarty), (void*)(&wStarty), sizeof(WORD), cmock_line, "Function 'ImageDecode' called with unexpected value for argument 'wStarty'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wWidth), (void*)(&wWidth), sizeof(WORD), cmock_line, "Function 'ImageDecode' called with unexpected value for argument 'wWidth'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wHeight), (void*)(&wHeight), sizeof(WORD), cmock_line, "Function 'ImageDecode' called with unexpected value for argument 'wHeight'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wFlags), (void*)(&wFlags), sizeof(WORD), cmock_line, "Function 'ImageDecode' called with unexpected value for argument 'wFlags'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pFileAPIs), (void*)(pFileAPIs), sizeof(IMG_FILE_SYSTEM_API), cmock_line, "Function 'ImageDecode' called with unexpected value for argument 'pFileAPIs'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pPixelOutput), (void*)(&pPixelOutput), sizeof(IMG_PIXEL_OUTPUT), cmock_line, "Function 'ImageDecode' called with unexpected value for argument 'pPixelOutput'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ImageDecode(CMOCK_ImageDecode_CALL_INSTANCE* cmock_call_instance, IMG_FILE* pImageFile, IMG_FILE_FORMAT eImgFormat, WORD wStartx, WORD wStarty, WORD wWidth, WORD wHeight, WORD wFlags, IMG_FILE_SYSTEM_API* pFileAPIs, IMG_PIXEL_OUTPUT pPixelOutput)
{
  cmock_call_instance->Expected_pImageFile = pImageFile;
  memcpy(&cmock_call_instance->Expected_eImgFormat, &eImgFormat, sizeof(IMG_FILE_FORMAT));
  memcpy(&cmock_call_instance->Expected_wStartx, &wStartx, sizeof(WORD));
  memcpy(&cmock_call_instance->Expected_wStarty, &wStarty, sizeof(WORD));
  memcpy(&cmock_call_instance->Expected_wWidth, &wWidth, sizeof(WORD));
  memcpy(&cmock_call_instance->Expected_wHeight, &wHeight, sizeof(WORD));
  memcpy(&cmock_call_instance->Expected_wFlags, &wFlags, sizeof(WORD));
  cmock_call_instance->Expected_pFileAPIs = pFileAPIs;
  memcpy(&cmock_call_instance->Expected_pPixelOutput, &pPixelOutput, sizeof(IMG_PIXEL_OUTPUT));
}

void ImageDecode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IMG_FILE* pImageFile, IMG_FILE_FORMAT eImgFormat, WORD wStartx, WORD wStarty, WORD wWidth, WORD wHeight, WORD wFlags, IMG_FILE_SYSTEM_API* pFileAPIs, IMG_PIXEL_OUTPUT pPixelOutput, BYTE cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ImageDecode_CALL_INSTANCE));
  CMOCK_ImageDecode_CALL_INSTANCE* cmock_call_instance = (CMOCK_ImageDecode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.ImageDecode_CallInstance = CMock_Guts_MemChain(Mock.ImageDecode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ImageDecode(cmock_call_instance, pImageFile, eImgFormat, wStartx, wStarty, wWidth, wHeight, wFlags, pFileAPIs, pPixelOutput);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(BYTE));
}

void IMG_vSetboundaries(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_IMG_vSetboundaries_CALL_INSTANCE* cmock_call_instance = (CMOCK_IMG_vSetboundaries_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.IMG_vSetboundaries_CallInstance);
  Mock.IMG_vSetboundaries_CallInstance = CMock_Guts_MemNext(Mock.IMG_vSetboundaries_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'IMG_vSetboundaries' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
}

void IMG_vSetboundaries_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_IMG_vSetboundaries_CALL_INSTANCE));
  CMOCK_IMG_vSetboundaries_CALL_INSTANCE* cmock_call_instance = (CMOCK_IMG_vSetboundaries_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.IMG_vSetboundaries_CallInstance = CMock_Guts_MemChain(Mock.IMG_vSetboundaries_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

